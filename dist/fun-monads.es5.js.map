{"version":3,"file":"fun-monads.es5.js","sources":["../src/Option/index.ts","../src/Try/index.ts","../src/Reader/index.ts","../src/Either/index.ts"],"sourcesContent":["'use strict'\nimport Functor from '../Functor'\n\n/**\n * Class `None<A>` represents non-existent values of type `A`.\n *\n * ```typescript\n * const s: None<any> = new None<any>()\n * const t: None<any> = Option.none\n * const u: None<any> = Option(null)\n * const v: None<any> = Option(undefined)\n * const w: None<any> = Option.some(null)\n * const x: None<any> = Option.some(undefined)\n * const y: None<any> = Option.apply(null)\n * const z: None<any> = Option.apply(undefined)\n * ```\n */\nexport class None<A> implements Functor<A, any, Option<A>> {\n  readonly type: string = 'None'\n\n  /**\n   * Returns true if the option is None, false otherwise.\n   */\n  isNone: boolean = true\n\n  /**\n   * Returns true if the option is an instance of Some, false otherwise.\n   */\n  isSome: boolean = false\n\n  /**\n   * isEmpty is a convenience shortcut to {@link isNone}\n   */\n  isEmpty = this.isNone\n\n  /**\n   * isSome is a convenience shortcut to {@link isSome}\n   */\n  isDefined = this.isSome\n  exists = this.has\n\n  /**\n   * get throws an Error if this is a None\n   */\n  get(): A {\n    throw new Error('Unsupported operation None.get')\n  }\n\n  /** Returns a Some containing the result of applying $f to this $option's\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   *  ```typescript\n   *  const f = (x:number): number => x * 2;\n   *  const o = Option<number>(5)\n   *  const result = o.map(f).getOrElse(-1) // 10\n   *  ```\n   *\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @see {@link flatMap}\n   *  @see {@link forEach}\n   */\n  map<B>(f: (a: A) => B): Option<B> {\n    return new None<B>()\n  }\n\n  /** Returns the result of applying $f to this Option's value if\n   * this Option is nonempty.\n   * Returns None if this Option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an Option (which could be None).\n   *\n   * ```typescript\n   * const f = (x:number) => Option(undefined);\n   * const o = Option<number>(5)\n   * const result = o.flatMap(f).getOrElse(-1) // -1\n   * ```\n   *\n   * @param  f   the function to apply\n   * @return Returns None in all cases\n   * @see {@link map}\n   * @see {@link forEach}\n   */\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    return new None<B>()\n  }\n\n  getOrElse(x: A): A {\n    return x\n  }\n\n  flatten(): Option<A> {\n    return this\n  }\n\n  orElse<B>(b: Option<B>): Option<A> | Option<B> {\n    return b\n  }\n\n  toList(): A[] {\n    return []\n  }\n\n  ap<B>(fa: Option<(a: A) => B>): Option<B> {\n    return new None<B>()\n  }\n\n  filter(p: (a: A) => boolean): Option<A> {\n    return new None<A>()\n  }\n\n  has(p: (a: A) => boolean): boolean {\n    return false\n  }\n\n  forEach(fn: (a: A) => any): void {\n    // noop\n  }\n}\n\n/**\n * Class `Some<A>` represents existing values of type `A`.\n * Some never contains null or undefined.\n *\n * ```typescript\n * const a:any = \"anything\"\n * const b: Some<any> = new Some<any>(a)\n * const c: Some<any> = Option.some(a)\n * const d: Some<any> = Option(a)\n * const e: Some<any> = Option.some(a)\n * const f: Some<any> = Option.apply(a)\n * ```\n */\nexport class Some<A> implements Functor<A, any, Option<A>> {\n  readonly type: string = 'Some'\n  readonly value: A\n  isNone: boolean = false\n  isSome: boolean = true\n  isEmpty = this.isNone\n  isDefined = this.isSome\n  exists = this.has\n\n  constructor(value: A) {\n    this.value = value\n    if (this.value == null) {\n      throw new Error('null or undefined exception. Please use Option.apply')\n    }\n    return this\n  }\n\n  get(): A {\n    return this.value\n  }\n\n  map<B>(f: (a: A) => B): Option<B> {\n    const res = f(this.value)\n    return res == null ? new None<B>() : new Some<B>(res)\n  }\n\n  flatMap<B>(f: (x: A) => Option<B>): Option<B> {\n    return f(this.value)\n  }\n\n  getOrElse(x: A): A {\n    return this.get()\n  }\n\n  flatten(): Option<A> {\n    const v: Option<A> = (this.value as unknown) as Option<A>\n    if (v && (v.isSome || v.isNone)) {\n      return v\n    }\n    return this\n  }\n\n  orElse<B>(b: Option<B>): Option<A> | Option<B> {\n    return this\n  }\n\n  toList(): A[] {\n    return [this.get()]\n  }\n\n  ap<B>(fa: Option<(a: A) => B>): Option<B> {\n    return this.map<B>(fa.get())\n  }\n\n  filter(p: (a: A) => boolean): Option<A> {\n    return p(this.get()) ? this : new None<A>()\n  }\n\n  has(p: (a: A) => boolean): boolean {\n    return p(this.get())\n  }\n\n  forEach(fn: (a: A) => any): void {\n    fn(this.get())\n  }\n}\n\n\nexport type Option<A> = None<A> | Some<A>\n\nexport function Option<A>(value: A): Option<A> {\n  return Option.apply(value)\n}\n\n/* istanbul ignore next */\nexport namespace Option {\n  export function none<A>(): Option<A> {\n    return new None<A>()\n  }\n\n  export const empty = none\n\n  export function some<A>(a: A): Option<A> {\n    return a == null ? new None<A>() : new Some(a)\n  }\n\n  export function apply<A>(a: A): Option<A> {\n    return some(a)\n  }\n\n  export function of<A>(a: A): Option<A> {\n    return some(a)\n  }\n\n  export function isSome<A>(fa: Option<A>): boolean {\n    return fa.isSome\n  }\n\n  export function isNone<A>(fa: Option<A>): boolean {\n    return fa.isNone\n  }\n\n  export const isEmpty = isNone\n  export const isDefined = isSome\n\n  export function get<A>(a: Option<A>): A {\n    return a.get()\n  }\n\n  export function map<A, B>(f: (x: A) => B, a: Option<A>): Option<B> {\n    return a.map(f)\n  }\n\n  export function flatMap<A, B>(f: (x: A) => Option<B>, a: Option<A>): Option<B> {\n    return a.flatMap(f)\n  }\n\n  export function getOrElse<A>(x: A, a: Option<A>): A {\n    return a.getOrElse(x)\n  }\n\n  export function flatten<A>(a: Option<A>): Option<A> {\n    return a.flatten()\n  }\n\n  export function ap<A, B>(f: Option<(a: A) => B>, a: Option<A>): Option<B> {\n    return a.ap(f)\n  }\n\n  export function filter<A>(p: (a: A) => boolean, a: Option<A>): Option<A> {\n    return a.filter(p)\n  }\n\n  export function has<A>(p: (a: A) => boolean, a: Option<A>): boolean {\n    return a.has(p)\n  }\n\n  export const exists = has\n\n  export function forEach<A>(f: (a: A) => void, a: Option<A>): void {\n    a.forEach(f)\n  }\n\n  export function orElse<A, B>(b: Option<B>, a: Option<A>): Option<A> | Option<B> {\n    return a.orElse(b)\n  }\n}\n","'use strict'\n\nimport Functor from '../Functor'\n\nexport class Success<A> implements Functor<A, any, Try<A>> {\n  readonly type: string = 'Success'\n  readonly value: A\n  isSuccess: boolean = true\n  isFailure: boolean = false\n\n  constructor(value: A) {\n    this.value = value\n    return this\n  }\n\n  flatMap<B extends any>(f: (x: A) => Try<B>): Try<B> {\n    try {\n      return f(this.value)\n    } catch (err) {\n      return new Failure<B>(err)\n    }\n  }\n\n  map<B extends any>(f: (x: A) => B): Try<B> {\n    return Try.apply(() => f(this.value))\n  }\n\n  fold<B extends any>(f: (x: Error) => B, s: (x: A) => B): B {\n    return s(this.value)\n  }\n\n  get(): A {\n    return this.value\n  }\n\n  getOrElse<B extends any>(b: () => B): A | B {\n    return this.value\n  }\n\n  orElse<B extends any>(b: Try<B>): Try<A> | Try<B> {\n    return this\n  }\n\n  flatten(): Try<A> {\n    const v: Try<A> = (this.value as unknown) as Try<A>\n    if (v && (v.isSuccess || v.isFailure)) {\n      return v\n    }\n    return this\n  }\n\n  forEach(fn: (a: A) => any): void {\n    fn(this.get())\n  }\n\n  filter(p: (a: A) => boolean): Try<A> {\n    try {\n      return p(this.get())\n        ? this\n        : new Failure<A>(new Error('Predicate does not hold for value ' + this.value))\n    } catch (err) {\n      return new Failure<A>(err)\n    }\n  }\n\n  recover<B extends any>(pf: (x: Error) => Try<B>): Try<B> {\n    return new Success<B>((this.value as unknown) as B)\n  }\n\n  failed(): Try<A> | Try<Error> {\n    return new Failure<A>(new Error('Unsupported operation. Success failed'))\n  }\n\n  ap<B extends any>(fa: Try<(a: A) => B>): Try<B> {\n    return this.map<B>(fa.get())\n  }\n}\n\nexport class Failure<A> implements Functor<A, any, Try<A>> {\n  readonly type: string = 'Failure'\n  readonly value: Error\n  isSuccess: boolean = false\n  isFailure: boolean = true\n\n  constructor(value: Error) {\n    this.value = value\n    return this\n  }\n\n  flatMap<B extends any>(f: (x: A) => Try<B>): Try<B> {\n    return new Failure<B>(this.value)\n  }\n\n  map<B extends any>(f: (x: A) => B): Try<B> {\n    return new Failure<B>(this.value)\n  }\n\n  fold<B extends any>(f: (x: Error) => B, s: (x: A) => B): B {\n    return f(this.value)\n  }\n\n  get(): A {\n    throw this.value\n  }\n\n  getOrElse<B extends any>(b: () => B): A | B {\n    return b()\n  }\n\n  orElse<B extends any>(b: Try<B>): Try<A> | Try<B> {\n    return b\n  }\n\n  flatten(): Try<A> {\n    return this\n  }\n\n  forEach(fn: (a: A) => any): void {\n    // noop\n  }\n\n  filter(p: (a: A) => boolean): Try<A> {\n    return this\n  }\n\n  recover<B extends any>(pf: (x: Error) => Try<B>): Try<B> {\n    try {\n      return pf(this.value)\n    } catch (err) {\n      return new Failure<B>(err)\n    }\n  }\n\n  failed(): Try<A> | Try<Error> {\n    return new Success<Error>(this.value)\n  }\n\n  ap<B extends any>(fa: Try<(a: A) => B>): Try<B> {\n    return new Failure<B>(this.value)\n  }\n}\n\nexport type Try<A> = Success<A> | Failure<A>\n\nexport function Try<A>(value: () => A): Try<A> {\n  return Try.apply(value)\n}\n\n/* istanbul ignore next */\nexport namespace Try {\n  export function success<A>(value: A): Try<A> {\n    return new Success<A>(value)\n  }\n\n  export function failure<A>(value: Error): Try<A> {\n    return new Failure<A>(value)\n  }\n\n  export function apply<A>(value: () => A): Try<A> {\n    try {\n      return new Success<A>(value())\n    } catch (err) {\n      return new Failure<A>(err)\n    }\n  }\n\n  export function of<A>(value: A): Try<A> {\n    try {\n      return new Success<A>((() => value)())\n    } catch (err) {\n      return new Failure<A>(err)\n    }\n  }\n\n  export function isSuccess<A>(a: Try<A>): boolean {\n    return a.isSuccess\n  }\n\n  export function isFailure<A>(a: Try<A>): boolean {\n    return a.isFailure\n  }\n\n  export function flatMap<A, B>(f: (x: A) => Try<B>, a: Try<A>): Try<B> {\n    return a.flatMap(f)\n  }\n\n  export function map<A, B>(f: (x: A) => B, a: Try<A>): Try<B> {\n    return a.map(f)\n  }\n\n  export function fold<A, B>(f: (x: Error) => B, s: (x: A) => B, a: Try<A>): B {\n    return a.fold(f, s)\n  }\n\n  export function get<A>(a: Try<A>): A {\n    return a.get()\n  }\n\n  export function getOrElse<A, B>(b: () => B, a: Try<A>): A | B {\n    return a.getOrElse(b)\n  }\n\n  export function orElse<A, B>(b: Try<B>, a: Try<A>): Try<A> | Try<B> {\n    return a.orElse(b)\n  }\n\n  export function flatten<A>(a: Try<A>): Try<A> {\n    return a.flatten()\n  }\n\n  export function forEach<A>(fn: (a: A) => any, a: Try<A>): void {\n    return a.forEach(fn)\n  }\n\n  export function filter<A>(p: (a: A) => boolean, a: Try<A>): Try<A> {\n    return a.filter(p)\n  }\n\n  export function recover<A, B>(pf: (x: Error) => Try<B>, a: Try<A>): Try<B> {\n    return a.recover(pf)\n  }\n\n  export function failed<A>(a: Try<A>): Try<A> | Try<Error> {\n    return a.failed()\n  }\n\n  export function ap<A, B>(f: Try<(a: A) => B>, a: Try<A>): Try<B> {\n    return a.ap(f)\n  }\n}\n","'use strict'\n\nimport Functor from '../Functor'\n\nexport class ReaderM<A, Config extends any> implements Functor<A, any, Reader<A, Config>> {\n  readonly type: string = 'Reader'\n  readonly value: (a: Config) => A\n\n  constructor(value: (a: Config) => A) {\n    this.value = value\n    return this\n  }\n\n  run(config: Config): A {\n    return this.value(config)\n  }\n\n  get(config: Config): A {\n    return this.run(config)\n  }\n\n  map<B>(f: (x: A) => B): Reader<B, Config> {\n    return new ReaderM(a => f(this.run(a)))\n  }\n\n  flatMap<B>(f: (x: A) => Reader<B, Config>): Reader<B, Config> {\n    return new ReaderM((a: Config): B => f(this.run(a)).run(a))\n  }\n\n  ap<B>(fa: Reader<(a: A) => B, undefined>): Reader<B, Config> {\n    return this.map<B>(fa.get(undefined))\n  }\n\n  zip<B extends A>(other: Reader<A, Config>): Reader<B[], Config> {\n    return this.flatMap((a: A) => other.map((b: A) => [a as B, b as B]))\n  }\n}\n\nexport type Reader<A, Config extends any> = ReaderM<A, Config>\n\nexport function Reader<A, Config>(value: (a: Config) => A): ReaderM<A, Config> {\n  return Reader.apply(value)\n}\n\n/* istanbul ignore next */\nexport namespace Reader {\n  export function of<A>(value: A): ReaderM<A, undefined> {\n    return new ReaderM<A, undefined>(() => value)\n  }\n\n  export function apply<A, Config>(fn: (a: Config) => A): ReaderM<A, Config> {\n    return new ReaderM<A, Config>(fn)\n  }\n\n  export function run<A, Config>(config: Config, r: Reader<A, Config>): A {\n    return r.run(config)\n  }\n\n  export function get<A, Config>(config: Config, r: Reader<A, Config>): A {\n    return r.get(config)\n  }\n\n  export function map<A, B, Config>(f: (x: A) => B, r: Reader<A, Config>): Reader<B, Config> {\n    return r.map(f)\n  }\n\n  export function flatMap<A, B, Config>(\n    f: (x: A) => Reader<B, Config>,\n    r: Reader<A, Config>\n  ): Reader<B, Config> {\n    return r.flatMap(f)\n  }\n\n  export function ap<A, B, Config>(\n    fa: Reader<(c: A) => B, undefined>,\n    r: Reader<A, Config>\n  ): Reader<B, Config> {\n    return r.ap(fa)\n  }\n\n  export function zip<A, B extends A, Config>(\n    other: Reader<A, Config>,\n    r: Reader<A, Config>\n  ): Reader<B[], Config> {\n    return r.flatMap((a: A) => other.map((b: A) => [a as B, b as B]))\n  }\n}\n","'use strict'\nimport { Option } from '../Option'\nimport Functor from '../Functor'\n\n/**\n * @ignore\n */\nconst leftProjection = <A, B>(that: Either<A, B>) => ({\n  get: () => {\n    if (that.isLeft) {\n      return that.value\n    }\n    throw new Error('Unsupported operation')\n  },\n  getOrElse: <A1, B1>(x: Either<A1, B1>): Either<A1, B1> => {\n    if (that.isLeft) {\n      return (that as unknown) as Either<A1, B1>\n    }\n    return x\n  },\n  fold: <C>(l: (a: A) => C, r: (b: B) => C): C => {\n    if (that.isLeft) {\n      return l(that.value as A)\n    } else {\n      return r(that.value as B)\n    }\n  },\n  map: <A1>(f: (a: A) => A1): Either<A1, B> => {\n    if (that.isLeft) {\n      return Left(f(that.value as A)).left\n    }\n    return (that as unknown) as Either<A1, B>\n  },\n  flatMap: <A1, B1>(f: (a: A) => Either<A1, B1>): Either<A1, B1> => {\n    if (that.isLeft) {\n      return f(that.value as A)\n    }\n    return (that as unknown) as Either<A1, B1>\n  },\n  forEach: (f: (a: A) => void): void => {\n    if (that.isLeft) {\n      f(that.value as A)\n    }\n  },\n  forAll: (p: (a: A) => boolean): boolean => {\n    if (that.isLeft) {\n      return p(that.value as A)\n    }\n    return true\n  },\n  exists: (p: (a: A) => boolean): boolean => {\n    if (that.isLeft) {\n      return p(that.value as A)\n    }\n    return false\n  },\n  toList: (): A[] => {\n    if (that.isLeft) {\n      return [that.value as A]\n    }\n    return []\n  },\n  filter: (p: (a: A) => boolean): Option<Either<A, B>> => {\n    if (that.isLeft && p(that.value as A)) {\n      return Option.some(that)\n    }\n    return Option.none()\n  },\n  isRight: that.isRight,\n  isLeft: that.isLeft\n})\n\n/**\n * @ignore\n */\nconst rightProjection = <A, B>(that: Either<A, B>) => ({\n  get: () => {\n    if (that.isRight) {\n      return that.value\n    }\n    throw new Error('Unsupported operation')\n  },\n  getOrElse: <A1, B1>(x: Either<A1, B1>): Either<A1, B1> => {\n    if (that.isRight) {\n      return (that as unknown) as Either<A1, B1>\n    }\n    return x\n  },\n  fold: <C>(l: (a: A) => C, r: (b: B) => C): C => {\n    if (that.isRight) {\n      return r(that.value as B)\n    } else {\n      return l(that.value as A)\n    }\n  },\n  map: <B1>(f: (b: B) => B1): Either<A, B1> => {\n    if (that.isRight) {\n      return Right(f(that.value as B))\n    }\n    return (that as unknown) as Either<A, B1>\n  },\n  flatMap: <A1, B1>(f: (b: B) => Either<A1, B1>): Either<A1, B1> => {\n    if (that.isRight) {\n      return f(that.value as B)\n    }\n    return (that as unknown) as Either<A1, B1>\n  },\n  forEach: (f: (b: B) => void): void => {\n    if (that.isRight) {\n      f(that.value as B)\n    }\n  },\n  forAll: (p: (b: B) => boolean): boolean => {\n    if (that.isRight) {\n      return p(that.value as B)\n    }\n    return true\n  },\n  exists: (p: (b: B) => boolean): boolean => {\n    if (that.isRight) {\n      return p(that.value as B)\n    }\n    return false\n  },\n  toList: (): A[] => {\n    if (that.isRight) {\n      return [that.value as A]\n    }\n    return []\n  },\n  filter: (p: (a: A) => boolean): Option<Either<A, B>> => {\n    if (that.isRight && p(that.value as A)) {\n      return Option.some(that)\n    }\n    return Option.none()\n  },\n  isRight: that.isRight,\n  isLeft: that.isLeft\n})\n\nexport class RightM<A, B> implements Functor<A, B, Either<A, B>> {\n  readonly type: string = 'Right'\n  readonly value: B\n  readonly isRight: boolean = true\n  readonly isLeft: boolean = false\n\n  constructor(value: B) {\n    this.value = value\n    return this\n  }\n\n  left: any = leftProjection(this)\n  right: any = rightProjection(this)\n\n  get = this.right.get\n  fold = this.right.fold\n  map = this.right.map\n  flatMap = this.right.flatMap\n  forEach = this.right.forEach\n  getOrElse = this.right.getOrElse\n  forAll = this.right.forAll\n  exists = this.right.exists\n  toList = this.right.toList\n  filter = this.right.filter\n\n  swap(): Either<B, A> {\n    return Left<B, A>(this.value)\n  }\n}\n\nexport class LeftM<A, B> implements Functor<A, B, Either<A, B>> {\n  readonly type: string = 'Left'\n  readonly value: A\n  readonly isRight: boolean = false\n  readonly isLeft: boolean = true\n\n  constructor(value: A) {\n    this.value = value\n    return this\n  }\n\n  left: any = leftProjection(this)\n  right: any = rightProjection(this)\n\n  get = this.right.get\n  fold = this.right.fold\n  map = this.right.map\n  flatMap = this.right.flatMap\n  forEach = this.right.forEach\n  getOrElse = this.right.getOrElse\n  forAll = this.right.forAll\n  exists = this.right.exists\n  toList = this.right.toList\n  filter = this.right.filter\n\n  swap(): Either<B, A> {\n    return Right<B, A>(this.value)\n  }\n}\n\nexport function Either<A, B>(value: B): Either<A, B> {\n  return Right<A, B>(value)\n}\n\nexport function Right<A, B>(value: B): Either<A, B> {\n  return Either.apply<A, B>(value)\n}\n\nexport function Left<A, B>(value: A): Either<A, B> {\n  return new LeftM<A, B>(value)\n}\n\nexport type Left<A, B> = LeftM<A, B>\nexport type Right<A, B> = RightM<A, B>\nexport type Either<A, B> = Left<A, B> | Right<A, B>\n\nexport namespace Either {\n  export function apply<A, B>(value: B): Either<A, B> {\n    return new RightM<A, B>(value)\n  }\n\n  export function of<A, B>(value: B): Either<A, B> {\n    return new RightM<A, B>(value)\n  }\n\n  export function get<A, B>(e: Either<A, B>): A | B {\n    return e.get()\n  }\n\n  export function fold<A, B, C>(l: (a: A) => C, r: (b: B) => C, e: Either<A, B>): C {\n    return e.fold(l, r)\n  }\n\n  export function map<A, B, C>(f: (x: A | B) => C, e: Either<A, B>): Either<A, C> | Either<C, A> {\n    return e.map(f)\n  }\n\n  export function flatMap<A, B, A1, B1>(\n    f: (a: A) => Either<A1, B1>,\n    e: Either<A, B>\n  ): Either<A1, B1> {\n    return e.flatMap(f)\n  }\n\n  export function swap<A, B>(e: Either<A, B>): Either<B, A> {\n    return e.swap()\n  }\n\n  export function forEach<A, B, C>(f: (x: A | B) => void, e: Either<A, B>): void {\n    e.forEach(f)\n  }\n\n  export function getOrElse<A, B, A1, B1>(x: Either<A1, B1>, e: Either<A, B>): Either<A1, B1> {\n    return e.getOrElse(x)\n  }\n\n  export function forAll<A, B>(p: (b: B) => boolean, e: Either<A, B>): boolean {\n    return e.forAll(p)\n  }\n\n  export function exists<A, B>(p: (b: B) => boolean, e: Either<A, B>): boolean {\n    return e.exists(p)\n  }\n\n  export function toList<A, B>(e: Either<A, B>): B[] | A[] {\n    return e.toList()\n  }\n\n  export function filter<A, B>(p: (a: A) => boolean, e: Either<A, B>): Option<Either<A, B>> {\n    return e.filter(p)\n  }\n}\n"],"names":[],"mappings":"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"}