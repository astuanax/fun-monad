{"version":3,"file":"fun-monads.umd.js","sources":["../src/Option/index.ts","../src/Try/index.ts"],"sourcesContent":["'use strict'\n\n/**\n * Class `None<A>` represents non-existent values of type `A`.\n *\n * ```typescript\n * const s: None<any> = new None<any>()\n * const t: None<any> = Option.none\n * const u: None<any> = Option(null)\n * const v: None<any> = Option(undefined)\n * const w: None<any> = Option.some(null)\n * const x: None<any> = Option.some(undefined)\n * const y: None<any> = Option.apply(null)\n * const z: None<any> = Option.apply(undefined)\n * ```\n */\nexport class None<A> {\n  readonly type: string = 'None'\n\n  /**\n   * Returns true if the option is None, false otherwise.\n   */\n  isNone(): boolean {\n    return true\n  }\n\n  /**\n   * Returns true if the option is an instance of Some, false otherwise.\n   */\n  isSome(): boolean {\n    return false\n  }\n\n  /**\n   * isEmpty is a convenience shortcut to {@link isNone}\n   */\n  isEmpty = this.isNone\n\n  /**\n   * isSome is a convenience shortcut to {@link isSome}\n   */\n  isDefined = this.isSome\n\n  /**\n   * get throws an Error if this is a None\n   */\n  get(): A {\n    throw new Error('Unsupported operation None.get')\n  }\n\n  /** Returns a Some containing the result of applying $f to this $option's\n   * value if this $option is nonempty.\n   * Otherwise return $none.\n   *\n   *  ```typescript\n   *  const f = (x:number): number => x * 2;\n   *  const o = Option<number>(5)\n   *  const result = o.map(f).getOrElse(-1) // 10\n   *  ```\n   *\n   *  @note This is similar to `flatMap` except here,\n   *  $f does not need to wrap its result in an $option.\n   *\n   *  @see {@link flatMap}\n   *  @see {@link forEach}\n   */\n  map<B>(f: (a: A) => B): Option<B> {\n    return new None<B>()\n  }\n\n  /** Returns the result of applying $f to this Option's value if\n   * this Option is nonempty.\n   * Returns None if this Option is empty.\n   * Slightly different from `map` in that $f is expected to\n   * return an Option (which could be None).\n   *\n   *  ```typescript\n   *  const f = (x:number) => Option(undefined);\n   *  const o = Option<number>(5)\n   *  const result = o.flatMap(f).getOrElse(-1) // -1\n   *  ```\n   *\n   *  @param  f   the function to apply\n   *  @return Returns None in all cases\n   *  @see {@link map}\n   *  @see {@link forEach}\n   */\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    return new None<B>()\n  }\n\n  getOrElse(x: A): A {\n    return x\n  }\n\n  flatten<B>(): Option<B> {\n    return new None<B>()\n  }\n\n  orElse<B>(b: Option<B>): Option<A> | Option<B> {\n    return b\n  }\n\n  toList(): A[] {\n    return []\n  }\n\n  ap<B>(fa: Option<(a: A) => B>): Option<B> {\n    return new None<B>()\n  }\n\n  filter(p: (a: A) => boolean): Option<A> {\n    return new None<A>()\n  }\n\n  has(p: (a: A) => boolean): boolean {\n    return false\n  }\n\n  exists = this.has\n\n  forEach(fn: (a: A) => any): void {\n    // noop\n  }\n\n}\n\n\n/**\n * Class `Some<A>` represents existing values of type `A`.\n * Some never contains null or undefined.\n *\n * ```typescript\n * const a:any = \"anything\"\n * const b: Some<any> = new Some<any>(a)\n * const c: Some<any> = Option.some(a)\n * const d: Some<any> = Option(a)\n * const e: Some<any> = Option.some(a)\n * const f: Some<any> = Option.apply(a)\n * ```\n */\nexport class Some<A> {\n  readonly type: string = 'Some'\n  readonly value: A\n\n  constructor(value: A) {\n    this.value = value\n    if (this.value == null) {\n      throw new Error('null or undefined exception. Please use Option.apply')\n    }\n    return this\n  }\n\n  isNone(): boolean {\n    return false\n  }\n\n  isSome(): boolean {\n    return true\n  }\n\n  isEmpty = this.isNone\n  isDefined = this.isSome\n\n  get(): A {\n    return this.value\n  }\n\n  map<B>(f: (a: A) => B): Option<B> {\n    const res = f(this.value)\n    return res == null\n      ? new None<B>()\n      : new Some<B>(res)\n  }\n\n  flatMap<B>(f: (x: A) => Option<B>): Option<B> {\n    return f(this.value)\n  }\n\n  getOrElse(x: A): A {\n    return this.get()\n  }\n\n  flatten<B>(): Option<B> {\n    if (this.value instanceof Option) {\n      return this.value as unknown as Option<B>\n    } else {\n      return this as unknown as Option<B>\n    }\n  }\n\n  orElse<B>(b: Option<B>): Option<A> | Option<B> {\n    return this\n  }\n\n  toList(): A[] {\n    return [this.get()]\n  }\n\n  ap<B>(fa: Option<(a: A) => B>): Option<B> {\n    return this.map<B>(fa.get())\n  }\n\n  filter(p: (a: A) => boolean): Option<A> {\n    return p(this.get())\n      ? this\n      : new None<A>()\n  }\n\n  has(p: (a: A) => boolean): boolean {\n    return p(this.get())\n  }\n\n  exists = this.has\n\n  forEach(fn: (a: A) => any): void {\n    fn(this.get())\n  }\n}\n\nexport type Option<A> = None<A> | Some<A>\n\nexport function Option<A>(value: A): Option<A> {\n  return Option.apply(value)\n}\n\nexport namespace Option {\n  export function none<A>(): Option<A> {\n    return new None<A>()\n  }\n\n  export const empty = none\n\n  export function some<A>(a: A): Option<A> {\n    return a == null ? new None<A>() : new Some(a)\n  }\n\n  export function apply<A>(a: A): Option<A> {\n    return some(a)\n  }\n\n  export function isSome<A>(fa: Option<A>): boolean {\n    return fa.isSome()\n  }\n\n  export function isNone<A>(fa: Option<A>): boolean {\n    return fa.isNone()\n  }\n\n  export const isEmpty = isNone\n  export const isDefined = isSome\n\n  export function get<A>(a: Option<A>): A {\n    return a.get()\n  }\n\n  export function map<A, B>(f: (x: A) => B, a: Option<A>): Option<B> {\n    return a.map(f)\n  }\n\n  export function flatMap<A, B>(f: (x: A) => Option<B>, a: Option<A>): Option<B> {\n    return a.flatMap(f)\n  }\n\n  export function getOrElse<A>(x: A, a: Option<A>): A {\n    return a.getOrElse(x)\n  }\n\n  export function flatten<A>(a: Option<Option<A>>): Option<A> {\n    return a.getOrElse(new None<A>())\n  }\n\n  export function ap<A, B>(f: Option<(a: A) => B>, a: Option<A>): Option<B> {\n    return a.ap(f)\n  }\n\n  export function filter<A>(p: (a: A) => boolean, a: Option<A>): Option<A> {\n    return a.filter(p)\n  }\n\n  export function has<A>(p: (a: A) => boolean, a: Option<A>): boolean {\n    return a.has(p)\n  }\n\n  export const exists = has\n\n  export function forEach<A>(f: (a: A) => any, a: Option<A>): void {\n    a.forEach(f)\n  }\n\n  export function orElse<A, B>(b: Option<B>, a: Option<A>): Option<A> | Option<B> {\n    return a.orElse(b)\n  }\n\n}\n\n\n\n\n","'use strict'\n\nimport { Option } from '../Option'\n\nexport class Success<A> {\n  readonly type: string = 'Success'\n  readonly value: A\n\n  constructor(value: A) {\n    this.value = value\n    return this\n  }\n\n  isSuccess: boolean = true\n  isFailure: boolean = false\n\n  flatMap<B>(f: (x: A) => Try<B>): Try<B> {\n    try {\n      return f(this.value as A)\n    } catch (err) {\n      return new Failure<B>(err)\n    }\n  }\n\n  map<B>(f: (x: A) => B): Try<B> {\n    return Try.apply(() => f(this.value))\n  }\n\n  fold<B>(f: (x: Error) => B, s: (x: A) => B): B {\n    return s(this.value)\n  }\n\n  get(): A {\n    return this.value\n  }\n\n  getOrElse<B>(b: () => B): A | B {\n    return this.value\n  }\n\n  orElse<B>(b: Try<B>): Try<A> | Try<B> {\n    return this\n  }\n\n  flatten(): Try<A> {\n    if ((this.value as unknown as Try<A>).isSuccess) {\n      return this.get() as unknown as Try<A>\n    }\n    return this\n  }\n\n  forEach(fn: (a: A) => any): void {\n    fn(this.get())\n  }\n\n  filter(p: (a: A) => boolean): Try<A> {\n    try {\n      return p(this.get())\n        ? this\n        : new Failure<A>(new Error('Predicate does not hold for value ' + this.value))\n    } catch (err) {\n      return new Failure<A>(err)\n    }\n  }\n\n  recover<B>(pf: (x: Error) => Try<B>): Try<B> {\n    return new Success<B>(this.value as unknown as B)\n  }\n\n  failed(): Try<A> | Try<Error> {\n    return new Failure<A>(new Error('Unsupported operation. Success failed'))\n  }\n\n  ap<B>(fa: Try<(a: A) => B>): Try<B> {\n    return this.map<B>(fa.get())\n  }\n\n}\n\nexport class Failure<A> {\n  readonly type: string = 'Failure'\n  readonly value: Error\n\n  constructor(value: Error) {\n    this.value = value\n    return this\n  }\n\n  isSuccess: boolean = false\n  isFailure: boolean = true\n\n  flatMap<B>(f: (x: A) => Try<B>): Try<B> {\n    return new Failure<B>(this.value)\n  }\n\n  map<B>(f: (x: A) => B): Try<B> {\n    return new Failure<B>(this.value)\n  }\n\n  fold<B>(f: (x: Error) => B, s: (x: A) => B): B {\n    return f(this.value)\n  }\n\n  get(): A {\n    throw this.value\n  }\n\n  getOrElse<B>(b: () => B): A | B {\n    return b()\n  }\n\n  orElse<B>(b: Try<B>): Try<A> | Try<B> {\n    try {\n      return b\n    } catch (err) {\n      return new Failure<B>(err)\n    }\n  }\n\n  flatten(): Try<A> {\n    return this\n  }\n\n  forEach(fn: (a: A) => any): void {\n    // noop\n  }\n\n  filter(p: (a: A) => boolean): Try<A> {\n    return this\n  }\n\n  recover<B>(pf: (x: Error) => Try<B>): Try<B> {\n    try {\n      return pf(this.value)\n    } catch (err) {\n      return new Failure<B>(err)\n    }\n  }\n\n  failed(): Try<A> | Try<Error> {\n    return new Success<Error>(this.value)\n  }\n\n  ap<B>(fa: Try<(a: A) => B>): Try<B> {\n    return new Failure<B>(this.value)\n  }\n\n}\n\nexport type Try<A> = Success<A> | Failure<A>\n\nexport function Try<A>(value: () => A): Try<A> {\n  return Try.apply(value)\n}\n\nexport namespace Try {\n  export function success<A>(value: A): Try<A> {\n    return new Success<A>(value)\n  }\n\n  export function failure<A>(value: Error): Try<A> {\n    return new Failure<A>(value)\n  }\n\n  export function apply<A>(value: () => A): Try<A> {\n    try {\n      return new Success<A>(value())\n    } catch (err) {\n      return new Failure<A>(err)\n    }\n  }\n\n  export function isSuccess<A>(a: Try<A>): boolean {\n    return a.isSuccess\n  }\n\n  export function isFailure<A>(a: Try<A>): boolean {\n    return a.isFailure\n  }\n\n  export function flatMap<A, B>(f: (x: A) => Try<B>, a: Try<A>): Try<B> {\n    return a.flatMap(f)\n  }\n\n  export function map<A, B>(f: (x: A) => B,  a: Try<A>): Try<B> {\n    return a.map(f)\n  }\n\n  export function fold<A, B>(f: (x: Error) => B, s: (x: A) => B, a: Try<A>): B {\n    return a.fold(f, s)\n  }\n\n  export function get<A>(a: Try<A>): A {\n    return a.get()\n  }\n\n  export function getOrElse<A, B>(b: () => B, a: Try<A>): A | B {\n    return a.getOrElse(b)\n  }\n\n  export function orElse<A, B>(b: Try<B>, a: Try<A>): Try<A> | Try<B> {\n    return a.orElse(b)\n  }\n\n  export function flatten<A>(a: Try<A>): Try<A> {\n    return a.flatten()\n  }\n\n  export function forEach<A>(fn: (a: A) => any, a: Try<A>): void {\n    return a.forEach(fn)\n  }\n\n  export function filter<A>(p: (a: A) => boolean, a: Try<A>): Try<A> {\n    return a.filter(p)\n  }\n\n  export function recover<A, B>(pf: (x: Error) => Try<B>, a: Try<A>): Try<B> {\n    return a.recover(pf)\n  }\n\n  export function failed<A>(a: Try<A>): Try<A> | Try<Error> {\n    return a.failed()\n  }\n\n  export function ap<A, B>(f: Try<(a: A) => B>, a: Try<A>): Try<B> {\n    return a.ap(f)\n  }\n\n}\n\n\n"],"names":[],"mappings":"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"}